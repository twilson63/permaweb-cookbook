# [ANS-104: Bundled Data v2.0 - Binary Serialization](https://github.com/ArweaveTeam/arweave-standards/blob/master/ans/ANS-104.md)

상태: Standard

## 개요

이 문서는 번들된 바이너리 데이터의 포맷과 읽기/쓰기 지침을 설명합니다. 번들된 데이터는 여러 개의 독립적인 데이터 트랜잭션(본 문서에서는 DataItem으로 지칭)을 하나의 최상위 트랜잭션 안에 기록하는 방법입니다. DataItem은 소유자(owner), 데이터(data), 태그(tags), 대상(target), 서명(signature), id 등 일반 데이터 트랜잭션과 유사한 속성을 많이 공유합니다. 다만 토큰 전송 기능이 없고 보상(reward)이 없다는 점에서 다릅니다. 최상위 트랜잭션이 번들된 모든 데이터의 보상을 지불합니다.

## 동기

여러 개의 데이터 트랜잭션을 하나의 트랜잭션에 번들링하면 다음과 같은 이점이 있습니다:

- DataItem 작성자의 신원과 서명을 유지하면서 제3자에게 DataItem 비용 지불을 위임할 수 있음 — 작성자가 자금을 보유한 지갑을 가질 필요 없음
- 여러 DataItem을 그룹으로 기록 가능
- 논리적으로 독립적인 데이터 쓰기 작업들의 Arweave 네트워크 처리량을 증가

## 참조 구현

DataItem의 생성, 서명, 검증 및 번들 작업에 대한 참조 구현은 [TypeScript](https://github.com/ArweaveTeam/arweave-data)에 있습니다.

## 사양

### 1. 트랜잭션 포맷

#### 1.1 트랜잭션 태그

Bundle-Data의 번들은 다음 두 개의 태그가 반드시 존재해야 합니다(MUST):

- `Bundle-Format` 번들 포맷을 설명하는 문자열. 본 표준의 포맷은 `binary`
- `Bundle-Version` 버전 문자열. 본 표준에서 참조하는 버전은 `2.0.0`

버전 변경은 향후 인코딩 알고리즘 변경으로 발생할 수 있습니다.

#### 1.2 트랜잭션 본문 포맷

트랜잭션 본문 포맷은 다음 바이트 형식의 바이너리 데이터입니다.

`N = number of DataItems`

| Bytes           | Purpose                                                            |
| --------------- | ------------------------------------------------------------------ |
| 32              | Numbers of data items                                              |
| `N` x 64        | Pairs of size and entry ids [size (32 bytes), entry ID (32 bytes)] |
| Remaining bytes | Binary encoded data items in bundle                                |

#### 1.3 DataItem 포맷

DataItem은 트랜잭션과 유사한 속성을 가지는 바이너리 인코딩 객체입니다.

| Field               | Description                                    | Encoding | Length (in bytes)         | Optional           |
| ------------------- | ---------------------------------------------- | -------- | ------------------------- | ------------------ |
| signature type      | Type of key format used for the signature      | Binary   | 2                         | :x:                |
| signature           | A signature produced by owner                  | Binary   | Depends on signature type | :x:                |
| owner               | The public key of the owner                    | Binary   | 512                       | :x:                |
| target              | An address that this DataItem is being sent to | Binary   | 32 (+ presence byte)      | :heavy_check_mark: |
| anchor              | A value to prevent replay attacks              | Binary   | 32 (+ presence byte)      | :heavy_check_mark: |
| number of tags      | Number of tags                                 | Binary   | 8                         | :x:                |
| number of tag bytes | Number of bytes used for tags                  | Binary   | 8                         | :x:                |
| tags                | An avro array of tag objects                   | Binary   | Variable                  | :x:                |
| data                | The data contents                              | Binary   | Variable                  | :x:                |

모든 선택적(optional) 필드는 해당 필드의 존재 여부를 나타내는 선행 바이트를 가집니다(`1`은 존재, `0`은 존재하지 않음). 이 바이트에 대해 다른 값이 있으면 DataItem은 유효하지 않습니다.

태그 객체는 Apache Avro로 인코딩된 스트림으로, 객체 구조는 `{ name: string, value: string }` 입니다. 태그 객체들을 바이트 길이로 접두(prefix)하면 디코더는 원할 경우 이를 건너뛸 수 있습니다.

DataItem의 `anchor` 및 `target` 필드는 선택적입니다. `anchor`는 번들링 게이트웨이가 자신이나 사용자를 대상으로 하는 재생 공격(replay attacks)으로부터 보호를 제공하기 위해 사용할 수 있는 임의의 값입니다.

##### 1.3.1 태그 포맷

태그 파싱은 선택적이며, 태그는 바이트 길이로 접두되어 있습니다.

배포된 번들과의 호환을 위해, 태그 포맷은 다음 스키마를 사용하는 [Apache Avro](https://avro.apache.org/docs/current/spec.html) 입니다:

```json
{
  "type": "array",
  "items": {
    "type": "record",
    "name": "Tag",
    "fields": [
      { "name": "name", "type": "bytes" },
      { "name": "value", "type": "bytes" }
    ]
  }
}
```

보통 name과 value 필드는 UTF-8로 인코딩된 문자열이므로, 이 경우 필드 타입으로 `"bytes"` 대신 `"string"`을 지정할 수 있으며 avro가 자동으로 디코딩합니다.

필드 및 리스트 크기를 인코딩하기 위해, avro는 먼저 zig-zag로 인코딩하고 그 다음 가변 길이 정수로 인코딩하는 `long` 데이터타입을 사용합니다. 배열을 인코딩할 때 avro는 블록 단위의 스트리밍 접근을 제공합니다.

##### 1.3.1.1 ZigZag 코딩

[ZigZag](https://code.google.com/apis/protocolbuffers/docs/encoding.html#types)는 부호 비트를 1의 자리로 옮겨 작은 음수들이 높은 비트가 설정되지 않도록 하는 정수 포맷입니다. 주변 코드에서는 일반적으로 정수를 2의 보수(twos-complement)로 저장하므로 아래와 같이 변환할 수 있습니다.

Converting to ZigZag:

```
zigzag = twos_complement << 1;
if (zigzag < 0) zigzag = ~zigzag;
```

Converting from ZigZag:

```
if (zigzag & 1) zigzag = ~zigzag;
twos_complement = zigzag >> 1;
```

##### 1.3.1.2 가변 길이 정수 인코딩

[Variable-length integer](https://lucene.apache.org/java/3_5_0/fileformats.html#VInt)는 각 바이트의 8번째 비트가 다음 바이트(더 큰 중요도의 7비트)가 스트림에 계속되는지를 표시하는 7비트 리틀엔디안 형식입니다.

Converting to VInt:

```
// writes 'zigzag' to 'vint' buffer
offset = 0;
do {
  vint_byte = zigzag & 0x7f;
  zigzag >>= 7;
  if (zigzag)
    vint_byte |= 0x80;
  vint.writeUInt8(vint_byte, offset);
  offset += 1;
} while(zigzag);
```

Converting from VInt:

```
// constructs 'zigzag' from 'vint' buffer
zigzag = 0;
offset = 0;
do {
  vint_byte = vint.readUInt8(offset);
  zigzag |= (vint_byte & 0x7f) << (offset*7);
  vint_byte &= 0x80;
  offset += 1;
} while(vint_byte);
```

##### 1.3.1.3 Avro 태그 배열 포맷

[Avro 배열](https://avro.apache.org/docs/current/spec.html#array_encoding)은 여러 시퀀스로 나누어 올 수 있습니다. 각 시퀀스는 그 길이로 접두되며, 길이가 음수인 경우 길이와 시퀀스 콘텐츠 사이에 바이트 길이(size)가 삽입됩니다. 이는 더 큰 데이터의 스키마에서 시킹(seeking)을 제공하기 위해 사용됩니다. 배열의 끝은 길이가 0인 시퀀스로 표시됩니다.

완전한 태그 포맷은 단일 avro 배열이며, 아래 포맷 블록들로만 구성됩니다. 시퀀스는 count가 0인 블록으로 종료됩니다. size 필드는 count가 음수일 때만 존재하며, 이 경우 절대값을 사용해야 합니다.

| Field | Description                | Encoding    | Length   | Optional           |
| ----- | -------------------------- | ----------- | -------- | ------------------ |
| count | Number of items in block   | ZigZag VInt | Variable | :x:                |
| size  | Number of bytes if count<0 | ZigZag VInt | Variable | :heavy_check_mark: |
| block | Concatenated tag items     | Binary      | size     | :x:                |

##### 1.3.1.4 Avro 태그 항목 포맷

avro 배열의 각 항목은 이름(name)과 값(value)으로 이루어진 avro 문자열 또는 바이트 객체 쌍이며, 각각 길이로 접두됩니다.

| Field      | Description              | Encoding    | Length     | Optional |
| ---------- | ------------------------ | ----------- | ---------- | -------- |
| name_size  | Number of bytes in name  | ZigZag VInt | Variable   | :x:      |
| name       | Name of the tag          | Binary      | name_size  | :x:      |
| value_size | Number of bytes in value | ZigZag VInt | Variable   | :x:      |
| value      | Value of the tag         | Binary      | value_size | :x:      |

### 2. DataItem 서명 및 id

DataItem의 서명과 id는 Arweave 2.0 트랜잭션 서명과 유사한 방식으로 생성됩니다. 이는 Arweave 2.0 deep-hash 알고리즘을 사용합니다. 2.0 deep-hash 알고리즘은 임의로 중첩된 바이너리 데이터 배열(즉 재귀적 타입인 `DeepHashChunk = Uint8Array | DeepHashChunk[]`)에서 동작합니다.

deep-hash 알고리즘의 참조 구현은 [TypeScript](https://github.com/ArweaveTeam/arweave-js/blob/b1c4b2e378a1eb7dc1fbfaeee41492eb908a60c6/src/common/lib/deepHash.ts) 및 [Erlang](https://github.com/ArweaveTeam/arweave/blob/b316173cd42a53a59036241f8e164b615db9b40d/apps/arweave/src/ar_deep_hash.erl)에 있습니다.

DataItem에 대해 유효한 서명을 생성하려면, DataItem의 내용과 정적 버전 태그(static version tags)를 deep-hash 알고리즘에 전달하여 메시지를 얻습니다. 이 메시지는 DataItem의 소유자가 서명하여 서명을 생성합니다. DataItem의 id는 이 서명의 SHA256 다이제스트입니다.

서명할 메시지를 얻기 위해 deep-hash 알고리즘에 전달되는 정확한 구조와 내용은 다음과 같습니다:

```
[
  utf8Encoded("dataitem"),
  utf8Encoded("1"),
  owner,
  target,
  anchor,
  [
    ... [ tag.name, tag.value ],
    ... [ tag.name, tag.value ],
    ...
  ],
  data
]
```

#### 2.1 DataItem 검증

DataItem 검증은 번들 표준 내 일관성을 유지하는 데 핵심입니다. DataItem은 다음 조건을 모두 만족할 때에만 유효합니다(if and only if).<sup>1</sup>:

- id가 서명과 일치함(서명의 SHA-256을 통해)
- 서명이 소유자의 공개키와 일치함
- 태그들이 모두 유효함
- anchor가 32바이트를 초과하지 않음

태그 객체는 다음 조건을 모두 만족할 때 유효합니다:

- 태그 개수 <= 128
- 각 키의 길이 <= 1024 바이트
- 각 값의 길이 <= 3072 바이트
- 키와 값만을 포함함
- 키와 값 모두 비어 있지 않은 문자열임

### 3. DataItem 번들 작성

DataItem 번들을 작성하려면, 각 DataItem을 구성하고 서명하고 인코딩한 뒤 섹션 1에 명시된 트랜잭션 본문 포맷과 트랜잭션 태그로 트랜잭션에 배치해야 합니다.

#### 3.1 중첩 번들(Nested bundle)

Arweave 트랜잭션과 DataItem은 태깅 및 바이너리 페이로드 취급에 대해 유사한 사양을 가집니다. 따라서 ANS-104 번들 트랜잭션 태깅 및 바이너리 데이터 포맷 사양은 DataItem의 태그 및 바이너리 데이터 페이로드에 적용될 수 있습니다. 이러한 방식으로 DataItem을 조립하면 "부모(parent)"와 "자식(child)" 번들 간의 일대다 관계를 갖는 ANS-104 번들의 중첩을 제공할 수 있으며 이론적으로 무제한 깊이의 중첩이 가능합니다. 또한, 중첩된 DataItem 번들은 트리의 어떤 깊이에서든 비번들(non-Bundle) DataItem들과 이질적으로 혼합될 수 있습니다.

ANS-104 DataItem을 중첩 번들로 구성하려면:

- [섹션 1.1](#11-transaction-tags)에 명시된 사양대로 DataItem에 태그를 추가
- [섹션 1.2](#12-transaction-body-format)에 기술된 Bundle Transaction Body Format에 맞는 바이너리 페이로드를 DataItem에 제공 — 즉, 후속 중첩된 DataItem들의 개수, 크기 및 ID를 설명하는 번들 헤더. 각 중첩 DataItem은 [섹션 2.1](#21-verifying-a-dataitem)에 설명된 방식으로 검증 가능해야 함.

게이트웨이의 GQL 쿼리는 요청 시 DataItem 헤더에 대해 `bundledIn` 필드를 포함해야 하며, 이 필드는 DataItem이 바로 상위(parent)와 어떤 관계인지 나타내야 합니다. 어떤 중첩 번들이든 `bundledIn` 필드를 따라 부모 체인을 재귀적으로 추적하면 기본 레이어의 Arweave 트랜잭션으로 추적할 수 있어야 합니다.

### 4. DataItem 번들 읽기

DataItem 번들을 읽으려면, DataItem들을 나타내는 바이트 리스트를 각 쌍(pair)의 오프셋을 사용하여 분할(partition)할 수 있습니다. 그 다음 각 파티션을 DataItem 객체(예: Rust/Go 등의 언어에서는 `struct`, TypeScript에서는 `JSON`)로 파싱하면 됩니다.

이 방식은 단일 항목(singleton) 또는 전체 번들을 쿼리하는 것을 허용합니다.

#### 4.1 DataItem 인덱싱

이 포맷은 특정 필드들의 인덱싱을 O(N) 시간에 허용합니다. 게이트웨이는 조회 시간을 개선하기 위해 어떤 형태의 캐싱 또는 인덱싱을 수행할 수 있습니다.

<sup>1 - if and only if</sup>
