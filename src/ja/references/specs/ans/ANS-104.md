# [ANS-104: Bundled Data v2.0 - Binary Serialization](https://github.com/ArweaveTeam/arweave-standards/blob/master/ans/ANS-104.md)

ステータス: Standard

## 要約

本書はバンドル化されたバイナリデータのデータフォーマットと読み書きの手順を説明する。バンドル化データとは、複数の独立したデータトランザクション（本書では DataItem と呼ぶ）をひとつのトップレベルトランザクションに書き込む方法である。DataItem は通常のデータトランザクションと多くの同様のプロパティ（owner、data、tags、target、signature、id）を持つが、トークンを転送する能力や報酬は持たない点が異なる。トップレベルのトランザクションがバンドル内の全 DataItem に対する報酬を支払うためである。

## 動機

複数のデータトランザクションを 1 つにバンドルすることには、次のような利点がある：

- DataItem の支払いを第 3 者に委任しつつ、作成者の識別と署名を維持できる（作成者が資金のあるウォレットを持つ必要がない）
- 複数の DataItem をグループとして書き込める
- 論理的に独立したデータ書き込みの Arweave ネットワークへのスループットを向上できる

## 参照実装

DataItem の作成、署名、検証およびバンドルの操作に関する参照実装は [TypeScript](https://github.com/ArweaveTeam/arweave-data) にある。

## 仕様

### 1. トランザクションフォーマット

#### 1.1 トランザクションタグ

バンドルされた DataItems は、少なくとも次の 2 つのタグを持たなければならない（MUST）：

- `Bundle-Format` バンドルフォーマットを表す文字列。本標準のフォーマットは `binary`
- `Bundle-Version` バージョン文字列。本標準で参照するバージョンは `2.0.0`

将来的にエンコーディングアルゴリズムの変更によりバージョン変更が発生する可能性がある。

#### 1.2 トランザクションボディフォーマット

トランザクションボディのフォーマットは、以下のバイト配列によるバイナリデータである。

`N = number of DataItems`

| Bytes           | Purpose                                                            |
| --------------- | ------------------------------------------------------------------ |
| 32              | Numbers of data items                                              |
| `N` x 64        | Pairs of size and entry ids [size (32 bytes), entry ID (32 bytes)] |
| Remaining bytes | Binary encoded data items in bundle                                |

#### 1.3 DataItem フォーマット

DataItem はトランザクションに類似したプロパティを持つバイナリエンコードオブジェクトである。

| Field               | Description                          | Encoding | Length (in bytes)         | Optional           |
| ------------------- | ------------------------------------ | -------- | ------------------------- | ------------------ |
| signature type      | 署名に使用される鍵フォーマットの種類 | Binary   | 2                         | :x:                |
| signature           | owner によって生成された署名         | Binary   | Depends on signature type | :x:                |
| owner               | owner の公開鍵                       | Binary   | 512                       | :x:                |
| target              | この DataItem が送られるアドレス     | Binary   | 32 (+ presence byte)      | :heavy_check_mark: |
| anchor              | リプレイ攻撃を防止するための値       | Binary   | 32 (+ presence byte)      | :heavy_check_mark: |
| number of tags      | タグの数                             | Binary   | 8                         | :x:                |
| number of tag bytes | タグに使用されるバイト数             | Binary   | 8                         | :x:                |
| tags                | タグオブジェクトの avro 配列         | Binary   | Variable                  | :x:                |
| data                | データ本体                           | Binary   | Variable                  | :x:                |

すべてのオプションフィールドは、そのフィールドが存在するかを示す先頭バイトを持つ（存在する場合は `1`、存在しない場合は `0`）。このバイトが他の値の場合、DataItem は無効となる。

タグオブジェクトは、オブジェクト `{ name: string, value: string }` を表現する Apache Avro エンコードストリームである。タグオブジェクトにバイト長をプレフィックスすることで、デコーダは任意でそれらをスキップできる。

DataItem の `anchor` と `target` フィールドはオプションである。`anchor` は、バンドリングゲートウェイが自身やユーザーに対するリプレイ攻撃からの保護を提供するための任意の値である。

##### 1.3.1 タグフォーマット

タグのパースは任意であり、タグはバイト長でプレフィックスされているため必須ではない。

デプロイ済みバンドルに準拠するため、タグフォーマットは以下のスキーマを用いた [Apache Avro](https://avro.apache.org/docs/current/spec.html) である：

```json
{
  "type": "array",
  "items": {
    "type": "record",
    "name": "Tag",
    "fields": [
      { "name": "name", "type": "bytes" },
      { "name": "value", "type": "bytes" }
    ]
  }
}
```

通常、name と value フィールドは UTF-8 エンコードされた文字列であり、その場合はフィールド型として `"bytes"` の代わりに `"string"` を指定することで Avro が自動的にデコードする。

フィールドおよびリストのサイズをエンコードする際、avro は `long` 型を使用し、まず zig-zag エンコードし、その後可変長整数エンコードを行う。配列をエンコードする際、avro はブロックに分割してストリーミングする方式を提供する。

##### 1.3.1.1 ZigZag コーディング

[ZigZag](https://code.google.com/apis/protocolbuffers/docs/encoding.html#types) は、符号ビットを 1 の位に置く整数フォーマットで、小さな負の数が高いビットを持たないようにする。周辺コードでは通常の整数はほとんど二の補数表現で格納されるため、以下のように変換できる。

Converting to ZigZag:

```
zigzag = twos_complement << 1;
if (zigzag < 0) zigzag = ~zigzag;
```

Converting from ZigZag:

```
if (zigzag & 1) zigzag = ~zigzag;
twos_complement = zigzag >> 1;
```

##### 1.3.1.2 可変長整数コーディング

[可変長整数](https://lucene.apache.org/java/3_5_0/fileformats.html#VInt) は 7 ビットのリトルエンディアン整数フォーマットであり、各バイトの 8 ビット目がストリーム内に次のバイト（より高い重要度の 7 ビット）が続くかどうかを示す。

Converting to VInt:

```
// writes 'zigzag' to 'vint' buffer
offset = 0;
do {
  vint_byte = zigzag & 0x7f;
  zigzag >>= 7;
  if (zigzag)
    vint_byte |= 0x80;
  vint.writeUInt8(vint_byte, offset);
  offset += 1;
} while(zigzag);
```

Converting from VInt:

```
// constructs 'zigzag' from 'vint' buffer
zigzag = 0;
offset = 0;
do {
  vint_byte = vint.readUInt8(offset);
  zigzag |= (vint_byte & 0x7f) << (offset*7);
  vint_byte &= 0x80;
  offset += 1;
} while(vint_byte);
```

##### 1.3.1.3 Avro タグ配列フォーマット

[Avro 配列](https://avro.apache.org/docs/current/spec.html#array_encoding) は複数のアイテムシーケンスに分割される場合がある。各シーケンスはその長さでプレフィックスされ、負の値の場合は長さとシーケンス内容の間にバイト長が挿入される。これは大きなスキーマでシークを提供するために使用される。配列の終端は長さゼロのシーケンスで示される。

完全なタグフォーマットは、下記フォーマットのみで構成される単一の avro 配列である。シーケンスは count が 0 のブロックで終端される。count が負の場合にのみ size フィールドが存在し、その絶対値が使用される。

| Field | Description              | Encoding    | Length   | Optional           |
| ----- | ------------------------ | ----------- | -------- | ------------------ |
| count | ブロック内のアイテム数   | ZigZag VInt | Variable | :x:                |
| size  | count<0 の場合のバイト数 | ZigZag VInt | Variable | :heavy_check_mark: |
| block | 連結されたタグアイテム   | Binary      | size     | :x:                |

##### 1.3.1.4 Avro タグアイテムフォーマット

avro 配列の各アイテムは、長さでプレフィックスされた name と value のペア（avro string または bytes オブジェクト）である。

| Field      | Description      | Encoding    | Length     | Optional |
| ---------- | ---------------- | ----------- | ---------- | -------- |
| name_size  | name のバイト数  | ZigZag VInt | Variable   | :x:      |
| name       | タグの名前       | Binary      | name_size  | :x:      |
| value_size | value のバイト数 | ZigZag VInt | Variable   | :x:      |
| value      | タグの値         | Binary      | value_size | :x:      |

### 2. DataItem の署名と id

DataItem の署名と id は Arweave 2.0 トランザクション署名に類似した方法で構築される。Arweave 2.0 deep-hash アルゴリズムを使用する。2.0 deep-hash アルゴリズムは、任意のネストされたバイナリデータ配列、すなわち再帰的な型 `DeepHashChunk = Uint8Array | DeepHashChunk[]` に対して動作する。

deep-hash アルゴリズムの参照実装は [TypeScript](https://github.com/ArweaveTeam/arweave-js/blob/b1c4b2e378a1eb7dc1fbfaeee41492eb908a60c6/src/common/lib/deepHash.ts) と [Erlang](https://github.com/ArweaveTeam/arweave/blob/b316173cd42a53a59036241f8e164b615db9b40d/apps/arweave/src/ar_deep_hash.erl) にある。

DataItem に対して有効な署名を生成するために、DataItem の内容と静的バージョンタグを deep-hash アルゴリズムに渡してメッセージを得る。このメッセージを DataItem の owner が署名して署名値を生成する。DataItem の id はこの署名の SHA256 ダイジェストである。

署名対象メッセージを得るために deep-hash に渡される正確な構造と内容は次のとおり：

```
[
  utf8Encoded("dataitem"),
  utf8Encoded("1"),
  owner,
  target,
  anchor,
  [
    ... [ tag.name, tag.value ],
    ... [ tag.name, tag.value ],
    ...
  ],
  data
]
```

#### 2.1 DataItem の検証

DataItem の検証はバンドル標準の一貫性を維持するために重要である。DataItem は次の条件をすべて満たす場合に限り有効である（iff）<sup>1</sup>:

- id が署名と一致すること（署名の SHA-256 による）
- signature が owner の公開鍵と一致すること
- tags がすべて有効であること
- anchor が 32 バイトを超えないこと

タグオブジェクトは次を満たす場合に有効である：

- タグは <= 128 件であること
- 各キーは <= 1024 バイトであること
- 各値は <= 3072 バイトであること
- キーと値のみを含むこと
- キーと値の両方が空でない文字列であること

### 3. DataItems のバンドル書き込み

DataItems をバンドルとして書き込むには、各 DataItem を構築、署名、エンコードし、セクション 1 で指定されたトランザクションボディフォーマットとトランザクションタグを持つトランザクションに配置する。

#### 3.1 ネストされたバンドル

Arweave Transactions と DataItems はタグ付けおよびバイナリペイロードの保持に関して類似した仕様を持つ。そのため、ANS-104 のバンドルトランザクションのタグおよびバイナリデータフォーマット仕様を DataItem のタグおよびバイナリデータペイロードに適用できる。DataItem をこの方法で組み立てることで、親と子の間に一対多の関係を持つ ANS-104 バンドルのネスト化が可能となり、理論上無制限のネストレベルを実現できる。さらに、ネストされた DataItem バンドルは任意の深さでバンドルでない DataItem と異種混合できる。

ANS-104 DataItem をネストされたバンドルとして構築するには：

- [セクション 1.1](#11-transaction-tags) に記載の仕様に従って DataItem にタグを追加する
- [セクション 1.2](#12-transaction-body-format) に記載の Bundle トランザクションボディフォーマットに一致するバイナリペイロードを DataItem に提供する。すなわち、後続のネストされた DataItems のカウント、サイズ、および ID を示すバンドルヘッダを提供すること。これら各ネストされた DataItem は [セクション 2.1](#21-verifying-a-dataitem) に記載の検証方法で検証可能であるべきである。

Gateway の GQL クエリは、DataItem ヘッダの問い合わせ時に `bundledIn` フィールドを含めることができ、その値は DataItem とその直近の親との親子関係を示すべきである。任意のネストされたバンドルは、`bundledIn` フィールドを親のチェーンに沿って再帰的にたどることでベースレイヤの Arweave トランザクションまでトレース可能であるべきである。

### 4. DataItems のバンドル読み取り

DataItems のバンドルを読み取るには、DataItems を表すバイト列を各ペアのオフセットを用いて分割できる。続いて各パーティションを DataItem オブジェクト（Rust/Go 等の言語では struct、TypeScript では JSON）にパースすることができる。

これにより、単一の DataItem やバンドル全体のクエリが可能となる。

#### 4.1 DataItems のインデックス化

このフォーマットは特定フィールドのインデックス化を O(N) 時間で可能にする。ゲートウェイは検索時間を改善するためにキャッシュやインデックスを構築する可能性がある。

<sup>1 - if and only if</sup>
