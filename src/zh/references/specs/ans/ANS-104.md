# [ANS-104：Bundled Data v2.0 - 二进制序列化](https://github.com/ArweaveTeam/arweave-standards/blob/master/ans/ANS-104.md)

状态：标准

## 摘要

本文档描述了捆绑二进制数据（bundled binary data）的数据格式以及读写该格式的指引。Bundled data 是一种将多个独立的数据交易（在本文档中称为 DataItem）写入一个顶层交易的方法。DataItem 在许多属性上与一般数据交易相似，例如 owner、data、tags、target、signature 以及 id。但不同之处在于它无法转移代币，且没有奖励，因为顶层交易会为所有捆绑数据支付奖励。

## 动机

将多个数据交易捆绑成一个交易提供以下几项好处：

- 允许将对单一 DataItem 的付款委托给第三方，同时保留创建该 DataItem 的人的身份与签名，而用户本身不需持有有余额的钱包
- 允许多个 DataItem 以分组方式被写入
- 提高向 Arweave 网络写入逻辑上独立数据的吞吐量

## 参考实现

已有用于创建、签署与验证 DataItem 以及处理 bundles 的参考实现，参见 [TypeScript](https://github.com/ArweaveTeam/arweave-data)

## 规范

### 1. 交易格式

#### 1.1 交易标签

一个 DataItems 的 bundle 必须包含以下两个标签：

- `Bundle-Format`：描述捆绑格式的字符串。本标准的格式为 `binary`
- `Bundle-Version`：版本字符串。本标准所指的版本为 `2.0.0`

未来若编码算法改变，可能会产生版本变更

#### 1.2 交易主体格式

交易主体的格式为二进制数据，采用以下字节格式表示

`N = number of DataItems`

| Bytes           | Purpose                                                            |
| --------------- | ------------------------------------------------------------------ |
| 32              | Numbers of data items                                              |
| `N` x 64        | Pairs of size and entry ids [size (32 bytes), entry ID (32 bytes)] |
| Remaining bytes | Binary encoded data items in bundle                                |

（表格栏位说明：左栏为字节数、右栏为用途）

#### 1.3 DataItem 格式

DataItem 是一个二进制编码的对象，具有类似交易的属性

| Field               | 描述                       | 编码   | 长度（字节）              | 可选               |
| ------------------- | -------------------------- | ------ | ------------------------- | ------------------ |
| signature type      | 用于签名的密钥格式类型     | Binary | 2                         | :x:                |
| signature           | 由 owner 所产生的签名      | Binary | Depends on signature type | :x:                |
| owner               | 拥有者的公钥               | Binary | 512                       | :x:                |
| target              | 此 DataItem 要发送至的地址 | Binary | 32 (+ presence byte)      | :heavy_check_mark: |
| anchor              | 用以防止重放攻击的值       | Binary | 32 (+ presence byte)      | :heavy_check_mark: |
| number of tags      | 标签数量                   | Binary | 8                         | :x:                |
| number of tag bytes | 用于标签的字节数           | Binary | 8                         | :x:                |
| tags                | 一个 Avro 编码的标签数组   | Binary | Variable                  | :x:                |
| data                | 数据内容                   | Binary | Variable                  | :x:                |

所有可选字段前都有一个前导字节（leading byte），用以描述该字段是否存在（`1` 表示存在，`0` 表示不存在）。若该字节为其他值，则 DataItem 为无效。

一个 tag 对象是以 Apache Avro 编码的流，代表对象 `{ name: string, value: string }`。在标签对象前加上它们的字节长度，让解码器在需要时能跳过它们。

DataItem 中的 `anchor` 与 `target` 字段为可选字段。`anchor` 是一个任意值，可允许捆绑网关（bundling gateways）为其或其用户提供防止重放攻击的保护。

##### 1.3.1 标签格式

标签的解析为可选，因为它们已由字节长度前缀。

为符合已部署的 bundles，标签格式采用 [Apache Avro](https://avro.apache.org/docs/current/spec.html) 并使用以下 schema：

```json
{
  "type": "array",
  "items": {
    "type": "record",
    "name": "Tag",
    "fields": [
      { "name": "name", "type": "bytes" },
      { "name": "value", "type": "bytes" }
    ]
  }
}
```

通常 name 与 value 字段为 UTF-8 编码的字符串，在此情况下可以将字段类型指定为 `"string"` 而非 `"bytes"`，avro 将会自动解码它们。

为了编码字段与列表的大小，Avro 使用 `long` 数据类型，该类型会先进行 zig-zag 编码，然后使用变长整数编码（variable-length integer encoding），遵循现有的编码规范。当编码数组时，avro 提供一种流式方式，可将内容分割成区块。

##### 1.3.1.1 ZigZag 编码

[ZigZag](https://code.google.com/apis/protocolbuffers/docs/encoding.html#types) 是一种将符号位放在 1 位权（1s place）的整数格式，使得小的负数不会设置高位。在周边代码中，正常整数几乎总是以二补数（twos-complement）方式存储，两者可依下述方式互相转换。

转换为 ZigZag：

```
zigzag = twos_complement << 1;
if (zigzag < 0) zigzag = ~zigzag;
```

从 ZigZag 转换回来：

```
if (zigzag & 1) zigzag = ~zigzag;
twos_complement = zigzag >> 1;
```

##### 1.3.1.2 变长整数编码

[变长整数 (Variable-length integer)](https://lucene.apache.org/java/3_5_0/fileformats.html#VInt) 是一种 7 位小端（7-bit little-endian）整数格式，其中每个字节的第 8 位（最高位）用来指示流中是否还有另一个字节（其携带的是更高位的 7 个位元）。

转换为 VInt：

```
// writes 'zigzag' to 'vint' buffer
offset = 0;
do {
  vint_byte = zigzag & 0x7f;
  zigzag >>= 7;
  if (zigzag)
    vint_byte |= 0x80;
  vint.writeUInt8(vint_byte, offset);
  offset += 1;
} while(zigzag);
```

从 VInt 转换回来：

```
// constructs 'zigzag' from 'vint' buffer
zigzag = 0;
offset = 0;
do {
  vint_byte = vint.readUInt8(offset);
  zigzag |= (vint_byte & 0x7f) << (offset*7);
  vint_byte &= 0x80;
  offset += 1;
} while(vint_byte);
```

##### 1.3.1.3 Avro 标签数组格式

[Avro 数组](https://avro.apache.org/docs/current/spec.html#array_encoding) 可能会被拆成多个项目序列（sequence）。每个序列前都有其长度，该长度可能为负值，若为负值则在长度与序列内容之间会插入一个字节长度（byte length）。这在较大数据的 schema 中提供了寻址（seeking）的能力。数组结束以长度为零的序列表示。

完整的标签格式为单一 avro 数组，仅由下列格式的区块所构成。序列以一个 count 为 0 的区块终止。若 count 为负值，则 size 字段会存在，其绝对值应被使用。

| Field | 描述                  | 编码        | 长度     | 可选               |
| ----- | --------------------- | ----------- | -------- | ------------------ |
| count | 区块中的项目数量      | ZigZag VInt | Variable | :x:                |
| size  | 若 count<0 时的字节数 | ZigZag VInt | Variable | :heavy_check_mark: |
| block | 串接的标签项目        | Binary      | size     | :x:                |

##### 1.3.1.4 Avro 标签项目格式

Avro 数组的每一项目是一对 avro 字符串或 bytes 对象，分别为 name 与 value，两者皆以其长度作前缀。

| Field      | 描述           | 编码        | 长度       | 可选 |
| ---------- | -------------- | ----------- | ---------- | ---- |
| name_size  | name 的字节数  | ZigZag VInt | Variable   | :x:  |
| name       | 标签的名称     | Binary      | name_size  | :x:  |
| value_size | value 的字节数 | ZigZag VInt | Variable   | :x:  |
| value      | 标签的值       | Binary      | value_size | :x:  |

### 2. DataItem 的签名与 id

DataItem 的签名与 id 的建立方式类似 Arweave 2.0 交易签署。其使用 Arweave 2.0 的 deep-hash 算法。2.0 deep-hash 算法作用于任意嵌套的二进制数据数组，即递归类型的 `DeepHashChunk = Uint8Array | DeepHashChunk[]`。

deep-hash 算法的参考实现可见于 [TypeScript](https://github.com/ArweaveTeam/arweave-js/blob/b1c4b2e378a1eb7dc1fbfaeee41492eb908a60c6/src/common/lib/deepHash.ts) 与 [Erlang](https://github.com/ArweaveTeam/arweave/blob/b316173cd42a53a59036241f8e164b615db9b40d/apps/arweave/src/ar_deep_hash.erl)

要为 DataItem 产生有效签名，须将 DataItem 的内容以及静态版本标签传递给 deep-hash 算法以取得要签署的消息（message）。该消息由 DataItem 的 owner 使用其私钥签署以产生签名。DataItem 的 id 则为此签名的 SHA256 摘要。

传递给 deep-hash 算法以取得要签署消息的精确结构与内容如下：

```
[
  utf8Encoded("dataitem"),
  utf8Encoded("1"),
  owner,
  target,
  anchor,
  [
    ... [ tag.name, tag.value ],
    ... [ tag.name, tag.value ],
    ...
  ],
  data
]
```

#### 2.1 验证 DataItem

DataItem 的验证是维护 bundle 规范一致性的关键。DataItem 当且仅当（iff.）符合下列条件时为有效：<sup>1</sup>

- id 与签名相符（通过签名的 SHA-256）
- 签名与 owner 的公钥相符
- 所有标签皆有效
- anchor 不超过 32 字节

一个标签对象（tag object）当且仅当符合下列条件时为有效：

- 标签数量 <= 128
- 每个 key 的长度 <= 1024 字节
- 每个 value 的长度 <= 3072 字节
- 仅包含 key 与 value
- key 与 value 均为非空字符串

### 3. 写入一个 DataItems 的 Bundle

要写入一个 DataItems 的 bundle，应先建立每个 DataItem、签署、编码，然后将它们放入一个交易，其交易主体格式与交易标签须遵循第 1 节所述规范。

#### 3.1 嵌套 bundle

Arweave 交易与 DataItem 在标签及承载二进制载荷方面具有类似规范。因此，ANS-104 的 Bundle 交易标签与二进制数据格式规范可以套用到 DataItem 的标签与二进制数据载荷上。以此方式组装 DataItem，允许 ANS-104 Bundles 的嵌套（nesting），在「父」与「子」 bundle 之间形成一对多关系，且理论上可以达到无限层级的嵌套。此外，嵌套的 DataItem Bundles 可在任意深度与非-Bundle 的 DataItem 异质混合。

要建立一个作为嵌套 Bundle 的 ANS-104 DataItem：

- 如 [第 1.1 节](#11-transaction-tags) 所述，为 DataItem 新增标签
- 为 DataItem 提供符合 [第 1.2 节](#12-transaction-body-format) 所述 Bundle 交易主体格式的二进制载荷，即 Bundle 标头描述后续嵌套 DataItems 的计数、大小与 IDs，这些嵌套的 DataItems 应可使用 [第 2.1 节](#21-verifying-a-dataitem) 所述的方法验证

网关的 GQL 查询在返回 DataItem 头部时，应该在请求时包含 `bundledIn` 字段，其值指出该 DataItem 与其直接父项之间的父子关系。任何嵌套的 bundle 应能通过递归追溯 `bundledIn` 字段沿着父链直到基层的 Arweave 交易。

### 4. 读取一个 DataItems 的 Bundle

要读取一个 DataItems 的 bundle，可使用每对偏移量（offsets）来切分代表 DataItems 的字节序列。接着，每个分段可以解析为 DataItem 对象（在 Rust/Go 等语言为 struct，或在 TypeScript 为 JSON）。

这允许对单个项目或整个 bundle 进行查询。

#### 4.1 DataItems 的索引

此格式允许以 O(N) 时间索引特定字段。网关可采取某种缓存或索引机制以改善查询时间。

<sup>1 - 当且仅当</sup>
