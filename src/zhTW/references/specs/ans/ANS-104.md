# [ANS-104：Bundled Data v2.0 - 二進位序列化](https://github.com/ArweaveTeam/arweave-standards/blob/master/ans/ANS-104.md)

狀態：標準

## 摘要

本文檔描述了捆綁二進位資料（bundled binary data）的資料格式以及讀寫該格式的指引。Bundled data 是一種將多個獨立的資料交易（在本文檔中稱為 DataItem）寫入一個頂層交易的方法。DataItem 在許多屬性上與一般資料交易相似，例如擁有者（owner）、資料（data）、標籤（tags）、目標（target）、簽名（signature）以及 id。但不同之處在於它無法轉移代幣，且沒有獎勵，因為頂層交易會為所有捆綁資料支付獎勵。

## 動機

將多個資料交易捆綁成一個交易提供以下幾項好處：

- 允許將對單一 DataItem 的付款委派給第三方，同時保留建立該 DataItem 的人的身分與簽名，而使用者本身不需持有有餘額的錢包
- 允許多個 DataItem 以群組方式被寫入
- 提高向 Arweave 網路寫入邏輯上獨立資料的吞吐量

## 參考實作

已有用於建立、簽署與驗證 DataItem 以及處理 bundles 的參考實作，參見 [TypeScript](https://github.com/ArweaveTeam/arweave-data)

## 規範

### 1. 交易格式

#### 1.1 交易標籤

一個 DataItems 的 bundle 必須包含以下兩個標籤：

- `Bundle-Format`：描述捆綁格式的字串。本標準的格式為 `binary`
- `Bundle-Version`：版本字串。本標準所指的版本為 `2.0.0`

未來若編碼演算法改變，可能會產生版本變更

#### 1.2 交易主體格式

交易主體的格式為二進位資料，採以下位元格式表示

`N = number of DataItems`

| Bytes           | Purpose                                                            |
| --------------- | ------------------------------------------------------------------ |
| 32              | Numbers of data items                                              |
| `N` x 64        | Pairs of size and entry ids [size (32 bytes), entry ID (32 bytes)] |
| Remaining bytes | Binary encoded data items in bundle                                |

（表格欄位說明：左欄為位元組數、右欄為用途）

#### 1.3 DataItem 格式

DataItem 是一個二進位編碼的物件，具有類似交易的屬性

| Field               | 描述                       | 編碼   | 長度（位元組）            | 可選               |
| ------------------- | -------------------------- | ------ | ------------------------- | ------------------ |
| signature type      | 使用於簽名的金鑰格式類型   | Binary | 2                         | :x:                |
| signature           | 由 owner 所產生的簽名      | Binary | Depends on signature type | :x:                |
| owner               | 擁有者的公開金鑰           | Binary | 512                       | :x:                |
| target              | 此 DataItem 要發送至的位址 | Binary | 32 (+ presence byte)      | :heavy_check_mark: |
| anchor              | 用以防止重放攻擊的值       | Binary | 32 (+ presence byte)      | :heavy_check_mark: |
| number of tags      | 標籤數量                   | Binary | 8                         | :x:                |
| number of tag bytes | 用於標籤的位元組數         | Binary | 8                         | :x:                |
| tags                | 一個 avro 編碼的標籤陣列   | Binary | Variable                  | :x:                |
| data                | 資料內容                   | Binary | Variable                  | :x:                |

所有可選欄位的前面會有一個領先位元（leading byte），用以描述該欄位是否存在（`1` 表示存在，`0` 表示不存在）。若該位元為其他值，則 DataItem 為無效。

一個 tag 物件是以 Apache Avro 編碼的串流，代表物件 `{ name: string, value: string }`。在標籤物件前加上它們的位元長度，讓解碼器在需要時能跳過它們。

DataItem 中的 `anchor` 與 `target` 欄位為可選欄位。`anchor` 是一個任意值，可允許捆綁閘道（bundling gateways）為其或其使用者提供防止重放攻擊的保護。

##### 1.3.1 標籤格式

標籤的解析為可選，因為它們已由位元長度前綴。

為符合已部署的 bundles，標籤格式採用 [Apache Avro](https://avro.apache.org/docs/current/spec.html) 並使用以下 schema：

```json
{
  "type": "array",
  "items": {
    "type": "record",
    "name": "Tag",
    "fields": [
      { "name": "name", "type": "bytes" },
      { "name": "value", "type": "bytes" }
    ]
  }
}
```

通常 name 與 value 欄位為 UTF-8 編碼的字串，在此情況下可以將欄位型別指定為 `"string"` 而非 `"bytes"`，avro 將會自動解碼它們。

為了編碼欄位與列表的大小，avro 使用 `long` 資料型別，該型別會先進行 zig-zag 編碼，然後使用變長整數編碼（variable-length integer encoding），遵循現有的編碼規範。當編碼陣列時，avro 提供一種串流方式，可將內容分割成區塊。

##### 1.3.1.1 ZigZag 編碼

[ZigZag](https://code.google.com/apis/protocolbuffers/docs/encoding.html#types) 是一種將符號位放在 1 位權（1s place）的整數格式，使得小的負數不會設定高位元。在周邊程式碼中，正常整數幾乎總是以二補數（twos-complement）方式儲存，兩者可依下述方式互相轉換。

轉換為 ZigZag：

```
zigzag = twos_complement << 1;
if (zigzag < 0) zigzag = ~zigzag;
```

從 ZigZag 轉換回來：

```
if (zigzag & 1) zigzag = ~zigzag;
twos_complement = zigzag >> 1;
```

##### 1.3.1.2 變長整數編碼

[變長整數 (Variable-length integer)](https://lucene.apache.org/java/3_5_0/fileformats.html#VInt) 是一種 7 位元小端（7-bit little-endian）整數格式，其中每個位元組的第 8 位（最高位）用來指示串流中是否還有另一個位元組（其攜帶的是更高位的 7 個位元）。

轉換為 VInt：

```
// writes 'zigzag' to 'vint' buffer
offset = 0;
do {
  vint_byte = zigzag & 0x7f;
  zigzag >>= 7;
  if (zigzag)
    vint_byte |= 0x80;
  vint.writeUInt8(vint_byte, offset);
  offset += 1;
} while(zigzag);
```

從 VInt 轉換回來：

```
// constructs 'zigzag' from 'vint' buffer
zigzag = 0;
offset = 0;
do {
  vint_byte = vint.readUInt8(offset);
  zigzag |= (vint_byte & 0x7f) << (offset*7);
  vint_byte &= 0x80;
  offset += 1;
} while(vint_byte);
```

##### 1.3.1.3 Avro 標籤陣列格式

[Avro 陣列](https://avro.apache.org/docs/current/spec.html#array_encoding) 可能會被拆成多個項目序列（sequence）。每個序列前都有其長度，該長度可能為負值，若為負值則在長度與序列內容之間會插入一個位元組長度（byte length）。這在較大資料的 schema 中提供了尋址（seeking）的能力。陣列結束以長度為零的序列表示。

完整的標籤格式為單一 avro 陣列，僅由下列格式的區塊所構成。序列以一個 count 為 0 的區塊終止。若 count 為負值，則 size 欄位會存在，其絕對值應被使用。

| Field | 描述                    | 編碼        | 長度     | 可選               |
| ----- | ----------------------- | ----------- | -------- | ------------------ |
| count | 區塊中的項目數量        | ZigZag VInt | Variable | :x:                |
| size  | 若 count<0 時的位元組數 | ZigZag VInt | Variable | :heavy_check_mark: |
| block | 串接的標籤項目          | Binary      | size     | :x:                |

##### 1.3.1.4 Avro 標籤項目格式

Avro 陣列的每一項目是一對 avro 字串或 bytes 物件，分別為 name 與 value，兩者皆以其長度作前綴。

| Field      | 描述             | 編碼        | 長度       | 可選 |
| ---------- | ---------------- | ----------- | ---------- | ---- |
| name_size  | name 的位元組數  | ZigZag VInt | Variable   | :x:  |
| name       | 標籤的名稱       | Binary      | name_size  | :x:  |
| value_size | value 的位元組數 | ZigZag VInt | Variable   | :x:  |
| value      | 標籤的值         | Binary      | value_size | :x:  |

### 2. DataItem 的簽名與 id

DataItem 的簽名與 id 的建立方式類似 Arweave 2.0 交易簽署。其使用 Arweave 2.0 的 deep-hash 演算法。2.0 deep-hash 演算法作用於任意巢狀的二進位資料陣列，即遞迴型態的 `DeepHashChunk = Uint8Array | DeepHashChunk[]`。

deep-hash 演算法的參考實作可見於 [TypeScript](https://github.com/ArweaveTeam/arweave-js/blob/b1c4b2e378a1eb7dc1fbfaeee41492eb908a60c6/src/common/lib/deepHash.ts) 與 [Erlang](https://github.com/ArweaveTeam/arweave/blob/b316173cd42a53a59036241f8e164b615db9b40d/apps/arweave/src/ar_deep_hash.erl)

要為 DataItem 產生有效簽名，須將 DataItem 的內容以及靜態版本標籤傳遞給 deep-hash 演算法以取得要簽署的訊息（message）。該訊息由 DataItem 的 owner 使用其私鑰簽署以產生簽名。DataItem 的 id 則為此簽名的 SHA256 摘要。

傳遞給 deep-hash 演算法以取得要簽署訊息的精確結構與內容如下：

```
[
  utf8Encoded("dataitem"),
  utf8Encoded("1"),
  owner,
  target,
  anchor,
  [
    ... [ tag.name, tag.value ],
    ... [ tag.name, tag.value ],
    ...
  ],
  data
]
```

#### 2.1 驗證 DataItem

DataItem 的驗證是維持 bundle 規範一致性的關鍵。DataItem 當且僅當（iff.）符合下列條件時為有效：<sup>1</sup>

- id 與簽名相符（透過簽名的 SHA-256）
- 簽名與 owner 的公開金鑰相符
- 所有標籤皆有效
- anchor 不超過 32 位元組

一個標籤物件（tag object）當且僅當符合下列條件時為有效：

- 標籤數量 <= 128
- 每個 key 的長度 <= 1024 位元組
- 每個 value 的長度 <= 3072 位元組
- 僅包含 key 與 value
- key 與 value 皆為非空字串

### 3. 寫入一個 DataItems 的 Bundle

要寫入一個 DataItems 的 bundle，應先建立每個 DataItem、簽署、編碼，然後將它們放入一個交易，其交易主體格式與交易標籤須遵循第 1 節所述規範。

#### 3.1 巢狀 bundle

Arweave 交易與 DataItem 在標籤及承載二進位載荷方面具有類似規範。因此，ANS-104 的 Bundle 交易標籤與二進位資料格式規範可以套用到 DataItem 的標籤與二進位資料載荷上。以此方式組裝 DataItem，允許 ANS-104 Bundles 的巢狀（nesting），在「父」與「子」 bundle 之間形成一對多關係，且理論上可以達到無限層級的巢狀。此外，巢狀的 DataItem Bundles 可在任意深度與非-Bundle 的 DataItem 異質混合。

要建立一個作為巢狀 Bundle 的 ANS-104 DataItem：

- 如 [第 1.1 節](#11-transaction-tags) 所述，為 DataItem 新增標籤
- 為 DataItem 提供符合 [第 1.2 節](#12-transaction-body-format) 所述 Bundle 交易主體格式的二進位載荷，即 Bundle 標頭描述後續巢狀 DataItems 的計數、大小與 IDs，這些巢狀的 DataItems 應可使用 [第 2.1 節](#21-verifying-a-dataitem) 所述的方法驗證

Gateway 的 GQL 查詢在回傳 DataItem 標頭時，應在請求時包含 `bundledIn` 欄位，其值指出該 DataItem 與其直接父項之間的父子關係。任何巢狀的 bundle 應能透過遞迴追溯 `bundledIn` 欄位沿著父鏈直到基層的 Arweave 交易。

### 4. 讀取一個 DataItems 的 Bundle

要讀取一個 DataItems 的 bundle，可使用每對偏移量（offsets）來切分代表 DataItems 的位元列。接著，每個分段可以解析為 DataItem 物件（在 Rust/Go 等語言為 struct，或在 TypeScript 為 JSON）。

這允許對單一項目或整個 bundle 進行查詢。

#### 4.1 DataItems 的索引

此格式允許以 O(N) 時間索引特定欄位。閘道可採取某種快取或索引機制以改善查詢時間。

<sup>1 - 當且僅當</sup>
