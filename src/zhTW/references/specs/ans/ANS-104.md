# [ANS-104：打包資料 v2.0 - 二進位序列化](https://github.com/ArweaveTeam/arweave-standards/blob/master/ans/ANS-104.md)

狀態：標準

## 摘要

本文件描述打包二進位資料的格式以及讀寫此類資料的方法。打包資料是一種將多個獨立的資料交易（在本文件中稱為 DataItem）寫入一個頂層交易的方式。DataItem 與一般的資料交易有許多相同屬性，例如它具有 owner、data、tags、target、signature 和 id。但不同之處在於 DataItem 無法轉移代幣，亦無獎勵，因為頂層交易會為所有打包資料支付獎勵。

## 動機

將多個資料交易打包到單一交易中有若干好處：

- 允許將對 DataItem 的付款委託給第三方，同時保留建立該 DataItem 的人的身分與簽名，而該人無需擁有有餘額的錢包
- 允許將多個 DataItem 作為一個群組寫入
- 提升邏輯上獨立的資料寫入到 Arweave 網路的吞吐量

## 參考實作

有關 DataItem 的建立、簽名與驗證，以及與 bundle 互動的參考實作，可見 [TypeScript](https://github.com/ArweaveTeam/arweave-data)

## 規格

### 1. 交易格式

#### 1.1 交易標籤

一個 DataItem 的 bundle 必須包含以下兩個標籤：

- `Bundle-Format`：描述打包格式的字串。本標準的格式為 `binary`
- `Bundle-Version`：版本字串。本標準所指的版本為 `2.0.0`

未來若編碼演算法改變，版本可能會變更

#### 1.2 交易主體格式

交易主體格式為二進位資料，採用以下位元組格式

`N = DataItems 的數量`

| Bytes           | 用途                                                        |
| --------------- | ----------------------------------------------------------- |
| 32              | 資料項目數量                                                |
| `N` x 64        | 大小與條目 id 的配對 [size (32 bytes), entry ID (32 bytes)] |
| Remaining bytes | bundle 中二進位編碼的資料項目                               |

#### 1.3 DataItem 格式

DataItem 是一個二進位編碼的物件，具有類似交易的屬性

| 欄位                | 描述                       | 編碼   | 長度（位元組）     | 可選               |
| ------------------- | -------------------------- | ------ | ------------------ | ------------------ |
| signature type      | 用於簽章的金鑰格式類型     | Binary | 2                  | :x:                |
| signature           | 由 owner 產生的簽章        | Binary | 視簽章類型而定     | :x:                |
| owner               | 擁有者的公鑰               | Binary | 512                | :x:                |
| target              | 此 DataItem 要發送到的地址 | Binary | 32（外加存在位元） | :heavy_check_mark: |
| anchor              | 用以防止重放攻擊的值       | Binary | 32（外加存在位元） | :heavy_check_mark: |
| number of tags      | 標籤數量                   | Binary | 8                  | :x:                |
| number of tag bytes | 標籤所佔位元組數           | Binary | 8                  | :x:                |
| tags                | 一個 avro 陣列的標籤物件   | Binary | 可變               | :x:                |
| data                | 資料內容                   | Binary | 可變               | :x:                |

所有可選欄位將以一個領先位元（leading byte）表示該欄位是否存在（`1` 表示存在，`0` 表示不存在）。該位元若為其他值，則 DataItem 為無效。

標籤物件是一個 Apache Avro 編碼的串流，代表物件 `{ name: string, value: string }`。以位元組長度當作前綴，讓解碼器在需要時可以跳過標籤。

DataItem 中的 `anchor` 與 `target` 欄位為可選。`anchor` 是一個任意值，允許打包閘道（bundling gateways）為其或其使用者提供防重放保護。

##### 1.3.1 標籤格式

解析標籤是可選的，因為它們以位元組長度為前綴。

為了符合已部署的 bundle，標籤格式採用 [Apache Avro](https://avro.apache.org/docs/current/spec.html) 與下列 schema：

```json
{
  "type": "array",
  "items": {
    "type": "record",
    "name": "Tag",
    "fields": [
      { "name": "name", "type": "bytes" },
      { "name": "value", "type": "bytes" }
    ]
  }
}
```

通常 name 與 value 欄位會是 UTF-8 編碼的字串，在此情況下可將欄位類型指定為 `"string"`（取代 `"bytes"`），avro 將會自動解碼。

為了編碼欄位與列表的大小，avro 使用一種 `long` 資料類型，該類型先進行 zig-zag 編碼，然後再做變長整數編碼，使用既有的編碼規範。當編碼陣列時，avro 提供一種串流方式，能將內容分割成多個區塊。

##### 1.3.1.1 ZigZag 編碼

[ZigZag](https://code.google.com/apis/protocolbuffers/docs/encoding.html#types) 是一種整數格式，將符號位放在 1 位元的位置，讓小的負數沒有較高位元被設置。在周邊程式中，通常整數會以二補數（twos-complement）方式儲存，可如下面方式互相轉換。

轉換為 ZigZag：

```
zigzag = twos_complement << 1;
if (zigzag < 0) zigzag = ~zigzag;
```

從 ZigZag 轉回：

```
if (zigzag & 1) zigzag = ~zigzag;
twos_complement = zigzag >> 1;
```

##### 1.3.1.2 變長整數編碼

[變長整數](https://lucene.apache.org/java/3_5_0/fileformats.html#VInt)（Variable-length integer）是一種 7 位元小端的整數格式，每個位元組的第 8 位（最高位）用來表示接下來是否還有另一個（更高顯著度的）7 位元位元組在串流中。

轉換為 VInt：

```
// writes 'zigzag' to 'vint' buffer
offset = 0;
do {
  vint_byte = zigzag & 0x7f;
  zigzag >>= 7;
  if (zigzag)
    vint_byte |= 0x80;
  vint.writeUInt8(vint_byte, offset);
  offset += 1;
} while(zigzag);
```

從 VInt 轉回：

```
// constructs 'zigzag' from 'vint' buffer
zigzag = 0;
offset = 0;
do {
  vint_byte = vint.readUInt8(offset);
  zigzag |= (vint_byte & 0x7f) << (offset*7);
  vint_byte &= 0x80;
  offset += 1;
} while(vint_byte);
```

##### 1.3.1.3 Avro 標籤陣列格式

[Avro 陣列](https://avro.apache.org/docs/current/spec.html#array_encoding) 可能會被切分成多於一個的項目序列。每一序列以其長度為前綴，該長度可能為負值，在此情況下，長度與序列內容之間會插入一個位元組長度欄位。此機制用於較大資料的 schema 以提供尋找（seeking）。陣列結束由一個長度為零的序列表示。

完整的標籤格式為一個單一的 avro 陣列，由下述格式的區塊組成。序列由一個 count 為 0 的區塊終止。當 count 為負時，size 欄位才會出現，並應使用其絕對值。

| 欄位  | 描述                      | 編碼        | 長度 | 可選               |
| ----- | ------------------------- | ----------- | ---- | ------------------ |
| count | 區塊中的項目數            | ZigZag VInt | 可變 | :x:                |
| size  | 若 count<0 則為位元組數量 | ZigZag VInt | 可變 | :heavy_check_mark: |
| block | 連結的標籤項目            | Binary      | size | :x:                |

##### 1.3.1.4 Avro 標籤項目格式

avro 陣列的每一項目為一對 avro 字串或 bytes 物件，分別為 name 與 value，且各自以其長度為前綴。

| 欄位       | 描述             | 編碼        | 長度       | 可選 |
| ---------- | ---------------- | ----------- | ---------- | ---- |
| name_size  | name 的位元組數  | ZigZag VInt | 可變       | :x:  |
| name       | 標籤的名稱       | Binary      | name_size  | :x:  |
| value_size | value 的位元組數 | ZigZag VInt | 可變       | :x:  |
| value      | 標籤的值         | Binary      | value_size | :x:  |

### 2. DataItem 的簽名與 id

DataItem 的簽名與 id 的建立方式類似於 Arweave 2.0 的交易簽名。它使用 Arweave 2.0 的 deep-hash 演算法。2.0 的 deep-hash 演算法可作用於任意巢狀的二進位資料陣列，即遞迴型別 `DeepHashChunk = Uint8Array | DeepHashChunk[]`。

deep-hash 演算法的參考實作可見於 [TypeScript](https://github.com/ArweaveTeam/arweave-js/blob/b1c4b2e378a1eb7dc1fbfaeee41492eb908a60c6/src/common/lib/deepHash.ts) 與 [Erlang](https://github.com/ArweaveTeam/arweave/blob/b316173cd42a53a59036241f8e164b615db9b40d/apps/arweave/src/ar_deep_hash.erl)。

為了產生一個有效的 DataItem 簽章，會將 DataItem 的內容與靜態版本標籤傳入 deep-hash 演算法，以取得要簽署的訊息。該訊息會由 DataItem 的 owner 簽署以產生簽章。DataItem 的 id 則是此簽章的 SHA256 摘要。

傳入 deep-hash 演算法以取得要簽署訊息的精確結構與內容如下：

```
[
  utf8Encoded("dataitem"),
  utf8Encoded("1"),
  owner,
  target,
  anchor,
  [
    ... [ tag.name, tag.value ],
    ... [ tag.name, tag.value ],
    ...
  ],
  data
]
```

#### 2.1 驗證 DataItem

DataItem 的驗證是維持 bundle 標準一致性的關鍵。當且僅當（iff.） DataItem 滿足下列條件，才為有效。<sup>1</sup>：

- id 與簽章相符（透過對簽章做 SHA-256）
- 簽章與 owner 的公鑰相符
- 所有標籤皆有效
- anchor 不超過 32 位元組

標籤物件為有效當且僅當：

- 標籤數量 <= 128
- 每個鍵（key） <= 1024 位元組
- 每個值（value） <= 3072 位元組
- 僅包含鍵與值兩個欄位
- 鍵與值皆為非空字串

### 3. 寫入一個 DataItems 的 Bundle

要寫入一個 DataItems 的 bundle，應先建立、簽名、編碼每個 DataItem，並將它們放入一個交易中，該交易應使用第 1 節所指定的交易主體格式與交易標籤。

#### 3.1 巢狀 bundle

Arweave 的交易（Transactions）與 DataItems 在標籤與承載二進位有效載荷方面具有類似規範。因此，ANS-104 Bundle 交易的標籤與二進位資料格式規範可以套用於 DataItem 的標籤與二進位資料有效載荷。以此方式組裝 DataItem，能夠實現 ANS-104 Bundles 的巢狀（nested）結構，形成「父」與多個「子」bundle 的一對多關係，並在理論上支援不受限層數的巢狀。此外，巢狀的 DataItem Bundles 可以在任一深度與非 Bundle 的 DataItem 異構混合。

要構造一個 ANS-104 DataItem 作為巢狀 Bundle：

- 如 [第 1.1 節](#11-transaction-tags) 所述，為 DataItem 新增標籤
- 提供一個符合 [第 1.2 節](#12-transaction-body-format) 所描述之 Bundle 交易主體格式的二進位有效載荷，即 Bundle 標頭會概述後續巢狀 DataItems 的數量、大小與 ID，且每一個巢狀 DataItem 應能使用 [第 2.1 節](#21-verifying-a-dataitem) 描述的方法進行驗證。

Gateway 的 GQL 查詢對於 DataItem 標頭，應在請求時包含一個 `bundledIn` 欄位，其值表示該 DataItem 與其直接父項之間的父子關係。任何巢狀的 bundle 應可透過遞迴地沿著 `bundledIn` 欄位向上追溯至基層的 Arweave 交易。

### 4. 讀取一個 DataItems 的 Bundle

要讀取一個 DataItems 的 bundle，可使用每一對偏移量將代表 DataItems 的位元組串分割。接著，每一個分割區段可以解析成 DataItem 物件（例如在 Rust/Go 等語言為 struct，或在 TypeScript 中為 JSON）。

這允許查詢單一項目或整個 bundle。

#### 4.1 資料項目的索引

此格式允許以 O(N) 時間索引特定欄位。閘道端可以透過某種快取或索引方式來改善查詢時間。

<sup>1 - 當且僅當</sup>
